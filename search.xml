<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git 如何操作]]></title>
    <url>%2F2018%2F12%2F02%2FGit%20%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[远程创建仓库或者选择已有仓库新建远程仓库打开Github 或者其他远程代码托管平台, 点击右上角的 +号,点击 New repository 新建代码仓库 Repository name 仓库名 取名随意 Description 描述 随意 如果是Github 选择public 公有库, 私有库是收费的 是否同时创建readme.md 一般 打钩,不打也没关系 gitignore 是提交时的忽略文件,选择自己对应的语言会自动创建忽略文件, 也可在 .gitignore 中 licese 表明许可证信息, 是否允许转载,是否允许打包到商业应用 等 协议 点击创建 选择已有仓库如果已有仓库直接跳过 获取仓库地址直接点击右边靠上位置绿色的Clone or Download, 复制SSH 地址 克隆到本地到本地找到希望创建文件的位置,打开终端 cd 到选择的终端目录下 git clone &lt;仓库地址&gt; 例: git clone git@github.com:JXwilliamJi/TimeTest.git 找到操作目录注意,git操作的目录地址下必须含有.git文件夹,没有就要到含有.git 进行命令行操作 本地是否配置了登录方式普通账号邮箱登录git config --global user.name &quot;username&quot;git config --global user.email &quot;email&quot; RSA 登录需要本地创建RSA秘钥对, 私钥存储在本地作为登录的钥匙, 将公钥信息复制,粘贴到Github的SSH秘钥信息上,在右上角的Setting中 找SSH ssh-keygen -t rsa -C &quot;youremail@example.com&quot; -t 表明选择的是生成SSH-2的密钥-C 注释,给密钥对 加一个标识 本地是否配置了远程提交地址git remote 查看 如果是空, 那么需要添加一个提交地址 git remote add &lt;别名&gt; 例: git remote add origin &quot;git@github.com:xxx/xxx.git&quot; 再次git remote 查看 开始编写代码请在含有.git文件夹的目录下编写代码 或者创建文件夹 需要提交git add . 将当前 ./目录下所有有变化的文件提交到暂存区(如果删除了文件,这个就有问题了) 或者 git add --all 这个就算删除文件也没问题,提交所有 git commit -m &quot;this is a commit&quot; 将暂存区代码提交到工作区 git push origin master 将工作区的代码提交到origin 仓库的master 分支 origin 是之前就设置好的一个别名,可以修改和删除 需要打Tag拉倒吧,有这闲工夫请看我最后一行 需要拉分支拉倒吧,有这闲工夫请看我最后一行 看完以上步骤,只是为了学习四不四撒? 有现成的图形化为啥要学习这些,git 对你的没有提升,只需要了解怎么操作就行了 我选择 https://www.sourcetreeapp.com/]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[mac下正则工具安装工具Github地址 步骤主要如下: $ sudo gem install macgap,此工具允许web开发者使用HTML/CSS/JS 开发 macApp $ git clone https://github.com/Zjmainstay/RegexTesterForMac.git, 下载项目 cd RegexTesterForMac &amp;&amp; sh ./install.sh 运行脚本,编译生成app 在/build 点击即可运行app 功能很简单,自行了解 30分钟学习Regex正则表达式http://deerchao.net/tutorials/regex/regex.htm非常好的一篇教程,简单明了, 重点关注零宽断言,负向零宽断言,贪婪和懒惰 最后的处理选项针对C#,平衡组 很多语言不支持]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[荒野大镖客视频]]></title>
    <url>%2F2018%2F11%2F08%2F%E8%8D%92%E9%87%8E%E5%A4%A7%E9%95%96%E5%AE%A2%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>游戏视频</category>
      </categories>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 2D Roguelike(二)]]></title>
    <url>%2F2018%2F10%2F28%2FUnity2D%20Roguelike(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[基本地图的完善创建敌人创建玩家控制游戏玩家的移动12// 获取W的按键Input.GetKey (KeyCode.W); 创建UI场景切换其他添加背景音乐在GameManager 上添加AudioSource组件,添加音乐 手机控制器]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 2D Roguelike(一)]]></title>
    <url>%2F2018%2F10%2F28%2FUnity%202D%20Roguelike(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[2D 游戏制作学习Unity的官方教程 2D Roguelike tutorial 开发 游戏介绍这是官方提供的游戏,名字叫拾荒漫游者,我们从这个游戏大致可以了解下Unity的开发流程 需求游戏名称为: 拾荒者 大致介绍: 游戏有外围栏,障碍,敌人,食物,玩家和出口几个元素组成, 障碍和食物都是随机生成,玩家在左下角,出口在右上角 成功条件: 当玩家到达出口时,进入下一关卡 失败条件: 当玩家的食物为0的时候失败 具体逻辑: 玩家进行2步,敌人进行一步,障碍可以被攻击,初始时玩家100食物,每行进一步,消耗1点食物,被怪物攻击,消耗10点食物,吃食物可以增加食物数量,关卡的敌人数量和关卡数成正比,食物最大值和关卡数成正比 启动和资源准备工作创建项目取名为Roguelike,选择2D游戏,存储到指定位置 获取资源链接:https://pan.baidu.com/s/1LUiJBbRgL9FSy-J8vd590g密码:iz3r 官方资源 到Assets 商店中搜索2D Roguelike,或者到 首页 &gt; 必备工具 &gt; 视频教程项目资源 中找到 2D Roguelike 然后到~/Library/Unity/Asset Store 中查看资源,后缀是.unitypackage 导入资源 选择下载好的资源包,导入 查看资源 选择布局方式 文件创建在Assets 文件下创建下列文件夹,用于归类: Scenes 存储场景,场景就是同一个背景的游戏部分 Scripts 游戏脚本存储 Prefabs 预制体,可以批量产生同一类型的游戏物体 Animations 存放游戏动画和动画控制器 还有资源类文件,比如Audios,Vedios,Fonts等 资源准备阶段开始阶段,我们cmd+s 保存场景,就是将Hierachy里的游戏物体保存下来,保存到_main,放置到Scenes. 首先查看资源在Assets/Sprites,选择Scavengers_SpriteSheet, 在右侧 inspector 中 可以点击Sprite Editor查看精灵 游戏基本的画面,需要搭建如下 分析游戏画面是一个8 x 8 的格子,周边是一周墙,内部的4 x 4才会随机生成怪物和围墙以及食物,玩家出现在左下角,出口在右上角 创建玩家和敌人的游戏物体在 Project -&gt; Assets -&gt; Scavengers_SpriteSheet ,点开类似播放的按钮 按住Shift, 从 第一张选择到第六张, 拖动到 Hierarchy 下 出现以下界面,选择动画的名称 游戏物体取名为Player,动画取名为PlayerIdle(Idle动画-&gt; 等待时的动画), 动画控制器取名为PlayerController 按一下 w 快捷键,或者选取右上角的拖动标识,拖动角色 然后点击Game 查看效果 在Animation文件下,分别创建Aimation和AnimationController文件夹,分别放置 Player动画PlayerIdle和控制器PlayerController 同样创建2个敌人的游戏物体按照以上方法练习一遍,选择资源文件第6-11张 第一个敌人 12-17张第二个敌人 修改动画点击运行,发现动画太快了,我们点击动画,选择橘黄色的部分,可以设置speed,设置为 0.5,重新运行,会发现慢了很多,名字修改为PlayerIdle 创建玩家攻击和被攻击动画复选攻击动画(资源文件40-41张),拖动到Player的游戏物体身上 复选被攻击动画(资源文件46-47张),拖动到Player的游戏物体身上 怪物的同理,将动画的拖动到对应的文件中 动画之间的切换步骤如图,创建从基本状态到攻击状态的动画转换 同样的方法创建从攻击状态返回基本状态的转换 动画转换的设置点击之前生成的动画转换箭头,右侧Inspector查看 Has Exit Time: 是否播放完动画自动切换为之前的动画 Setting/Exit Time: 播放完动画的时间,上面的打钩才会有这个属性 Fixed Duration: 切换持续时间是和状态的时长独立的 Transiton Duration: 动画切换时长 Interruption Soutce: 可以被什么动画中断 Conditions: 动画切换的条件,一旦成立就会发生动画切换 创建动画切换的条件 创建一个Trigger 触发器,取名为Attack,以后代码中调用Attack即可调用 从普通状态到攻击状态的动画 创建 从攻击状态返回普通状态的动画,我们让攻击动画播放完就回到普通状态. 敌人和玩家也都创建好动画转换,完成后玩家和敌人的游戏资源就处理好了! 创建预制体 预制体相当于抽象父类,就是 预先制作好的游戏物体, 可以用它来copy 出同样的物体 将Hierachy 中的Player,Enemy1,Enemy2 拖动到Project 文件的Prefabs 文件下,生成预制体,顺便将Hierachy 中的变为蓝色字体的游戏物体删除,因为我们通过代码创建游戏物体. 创建地板,食物,以及障碍物的预制体首先创建8种地板的预制体选择图片32-39,分别创建Floor1- Floor8的预制体 创建食物苏打汽水,出口的预制体选择图片资源第18张创建苏打汽水,19张创建食物,20张创建出口 创建内外围墙的预制体创建3个外墙的预制体,图片资源 25,26,28 创建8个内墙的预制体, 图片资源 21-24,27,29-31 资源全部准备完毕 逻辑处理阶段创建游戏基本控制器和声音基本控制器我们点击Main Camera,在右侧的Inspector边栏中 找到Add Component,添加脚本: 查找New Script, 创建一个名称为MyLoader的脚本,这个脚本我们主要是加载游戏控制器和声音控制器 在Hierarchy中创建2个空的游戏物体, Create Empty,取名为MyGameManager和MySoundManager,将他们做成预制体,并从Hierachy 中删除掉这两个游戏物体 给 MyGameManager 添加2个脚本, 一个名为MapManager,一个名为GameManager 给 MySoundManager 添加1个脚本,取名为SoundManager 首先将所有的.cs文件统一放置到Script 文件夹中 编辑MyLoader.cs 1234567891011121314151617181920212223242526272829using System.Collections;using System.Collections.Generic;using UnityEngine;// 给class 添加命名空间,防止重名,相同命名空间可以直接引用namespace MyCompleted &#123; public class MyLoader : MonoBehaviour &#123; // 游戏管理器,public 属性会在Unity 中展示 public GameObject gamesManager; // 声音管理器 public GameObject soundsManager; // awake 在所有的start之前调用,一般我们在Awake中初始化数据,某些特殊的情况可以放到 Start()中 // 这个脚本加载的游戏物体一旦加载就会调用Awake,且一般只调用一次 void Awake () &#123; if (GameManager.instance == null) &#123; // 通过预制体实例化 GameObject.Instantiate (gamesManager); &#125; if (SoundManager.instance == null) &#123; // 实例化方法 GameObject.Instantiate (soundsManager); &#125; &#125; &#125;&#125; 在Unity 查看展示的 public 信息 将创建的MyGameManager和MySoundManager 两个预制体拖拽到属性后面的框中 然后给MyGameManager预制体的GameManager.cs和MySoundManager的SoundManager.cs添加单例方法instance,要不然MyLoader.cs报错 1234567891011121314151617181920212223242526272829303132333435namespace MyCompleted &#123; public class GameManager : MonoBehaviour &#123; // 单例方法 public static GameManager instance = null; // 关卡数 private int level = 1; // 这里根据 通过代码来创建地图 private MapManager mapSript; // 初始化数据,单例方法 void Awake () &#123; if (instance == null) &#123; instance = this; &#125;else if (instance != this) &#123; Destroy (this.gameObject); &#125; // 游戏物体不销毁(场景切换不销毁,一般场景切换游戏物体会销毁) DontDestroyOnLoad (this.gameObject); // 获取地图 this.mapSript = this.GetComponent&lt;MapManager&gt; (); // 初始化游戏数据 this.initGame (); &#125; // 初始化游戏数据 void initGame () &#123; // 初始化地图 &#125; &#125;&#125; 12345678910111213141516171819namespace MyCompleted &#123; public class SoundManager : MonoBehaviour &#123; // 单例方法 public static SoundManager instance = null; // 初始化数据,单例方法 void Awake () &#123; if (instance == null) &#123; instance = this; &#125;else if (instance != this) &#123; Destroy (this.gameObject); &#125; // 游戏物体不销毁(场景切换不销毁,一般场景切换游戏物体会销毁) DontDestroyOnLoad (this.gameObject); &#125; &#125;&#125; 一旦运行,Hierachy 中就会创建2个游戏物体,名称分别为MyGameManager和MySoundManager 创建地图编辑MapManager.cs 12345678910111213141516171819202122232425262728// 初始化public void setupScene(int level) &#123; // 等级初始化 this.level = level; // 根据 level 初始化数据 this.init (); // 创建地图 this.createMap ();&#125;// 初始化数据void init () &#123; // 创建外部包裹层 outwallsHolder = new GameObject (&quot;WallsHolder&quot;).transform; floorsHolder = new GameObject (&quot;FloorsHolder&quot;).transform;&#125;// 创建地图void createMap () &#123; // 创建外墙和地板 // 创建内墙,食物 // 创建出口&#125; 修改GameManager文件中的initGame方法 12345// 初始化游戏数据void initGame () &#123; // 初始化地图 this.mapSript.setupScene (level); &#125; 创建外墙和地板下面无论是外墙,地板和内墙,都是随机取图片组成地图 编译MapManager.cs 添加属性 12345678// 外墙的预制体数组public GameObject[] outwalls;// 地板的预制体数组public GameObject[] floors;// 设置 地图的长宽public int cols = 8;public int rows = 8; 创建工具方法,从数组中随机获取元素 1234// 随机获取数组里面的值T getRandom&lt;T&gt;(T[] obj) &#123; return obj[Random.Range (0, obj.Length)];&#125; 创建新的方法 123456789101112131415161718// 创建外墙和地板void createWallsAndFloors () &#123; for (int y = 0; y &lt; rows; y ++) &#123; for (int x = 0; x &lt; cols; x++) &#123; // 创建三维坐标点,z 默认是0 Vector3 vec = new Vector3 (x, y); if (x == 0 || x == cols - 1 || y == 0 || y == rows - 1) &#123; // 先创建最外层的 outwalls // 只有 x = 0,或者 y = 0 ,或者 x = cols - 1,或者 rows -1 GameObject obj = GameObject.Instantiate (getRandom (this.outwalls), vec, Quaternion.identity); &#125; else &#123; // 内部区域首先创建地板 GameObject obj = GameObject.Instantiate (getRandom(this.floors),vec,Quaternion.identity); &#125; &#125; &#125;&#125; 修改MapManager.cs中的createMap方法 123456789// 创建地图void createMap () &#123; // 创建外墙和地板 createWallsAndFloors(); // 创建内墙,食物 // 创建出口&#125; 运行查看效果,会看到地图偏了 摄像头设置设置摄像头的绝对坐标为(0,0),所以摄像头要有一定的便宜才能居中,中心点的位置如图 修改Transform 的Position 的坐标为(3.5,3.5,-1), z轴必须是负值才能看得见 Size 修改为 4 重新运行,查看效果 游戏物体归类我们查看Hierachy中会发现很多游戏物体,杂乱无章,我们想像文件夹一样有层级 游戏物体可以相互包裹,父物体可以包含多个子物体,多个子物体相当于一个整体(游戏物体的包裹其实是空间上的包裹,所以我们使用的 transform ) 修改MapManager.cs,新增属性 12345678910111213141516171819// 1. 定义父类的包裹属性// outwalls 的游戏物体private Transform outwallsHolder;// 地板的游戏物体private Transform floorsHolder;// 2. 初始化父类的包裹属性void init () &#123; outwallsHolder = new GameObject (&quot;OutwallsHolder&quot;).transform; floorsHolder = new GameObject (&quot;FloorsHolder&quot;).transform;&#125;// 3. 设置GameObject obj = GameObject.Instantiate (getRandom (this.outwalls), vec, Quaternion.identity);obj.transform.SetParent (outwallsHolder);GameObject obj = GameObject.Instantiate (getRandom(this.floors),vec,Quaternion.identity);obj.transform.SetParent (floorsHolder); 重新运行查看,会发现现在有了层级 创建内墙和食物内墙和食物的数量随机的,但是数量有一个取值范围 他们的位置也是随机的 数量随机,创建一个工具类来记录取值范围Unity 的Inspector只支持Object以及子类以及基本数据类型的展示,如果自定义的 class 类型需要支持Inspector展示,需要加上[System.Serializable] 1234567891011121314151617// 为了方便在 inspector 中展示类,这个是 count 类,展示最大值和最小值[System.Serializable]public class Count&#123; public int minimum; //Minimum value for our Count class. public int maximum; //Maximum value for our Count class. //Assignment constructor. public Count (int min, int max)&#123; minimum = min; maximum = max; &#125; // 获取到随机数 public int randomNum() &#123; return Random.Range (minimum, maximum+1); &#125;&#125; 位置随机,首先获取到所有可用地块的数组 1234567891011121314151617181920212223// 1. 定义一个 listprivate List&lt;Vector3&gt; positionList = new List&lt;Vector3&gt; ();// 2. 给数组赋值else &#123; // 内部区域首先创建地板 GameObject obj = GameObject.Instantiate (getRandom(this.floors),vec,Quaternion.identity); obj.transform.SetParent (floorsHolder); // 这个位置赋值可用地块的数组 if (!(x == 1 || x == cols - 2 || y == 1 || y == rows - 2)) &#123; // 初始化可用地块 positionList.Add (vec); &#125; &#125;// 3. 获取随机位置,然后移除掉,意味着一旦放了东西就不能放其他东西Vector3 randomPos() &#123; int randomNum = Random.Range (0,positionList.Count); Vector3 vec = positionList[randomNum]; positionList.Remove (vec); return vec;&#125; 创建内墙和食物 123456789101112131415// 创建内墙和食物void createInner () &#123; // 食物和内墙都是随机生成 // 食物 for(int num = 0; num &lt; foodCount.randomNum (); num ++) &#123; GameObject obj = GameObject.Instantiate (getRandom (this.foods), this.randomPos(), Quaternion.identity); obj.transform.SetParent (foodsHolder); &#125; // 内墙 for (int num = 0; num &lt; wallCount.randomNum(); num ++) &#123; GameObject obj = GameObject.Instantiate (getRandom (this.walls), this.randomPos (), Quaternion.identity); obj.transform.SetParent (wallsHoder); &#125;&#125; 创建出口123456Vector3 randomPos() &#123; int randomNum = Random.Range (0,positionList.Count); Vector3 vec = positionList[randomNum]; positionList.Remove (vec); return vec;&#125; 完善逻辑12345678void createMap () &#123; // 创建外墙和地板 createWallsAndFloors(); // 创建内墙,食物 createInner (); // 创建出口 createExit ();&#125; 运行游戏,查看效果 地图基本创建完毕!!!其他信息请参看 Unity 2D Rouguelike(二))]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习一]]></title>
    <url>%2F2018%2F10%2F21%2FC%2B%2B%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[函数重载C++ 支持函数重载 源于name mangling 或者叫 name decoration 技术, C++编译过程会对符号名(函数和参数名)进行改编,修饰 注意: 如果涉及到隐式转换,可能会报错,产生二义性! 12345678910111213141516171819void sum(long a) &#123; cout &lt;&lt; a &lt;&lt; endl;&#125;void sum(double a) &#123; cout &lt;&lt; a &lt;&lt; endl;&#125;int main () &#123; // 如果涉及到隐式转换报错 sum(10); // 如果要消除,必须新增一个参数是int的方法,消除隐式转换 return 0;&#125; externC++、C混合开发的时候,C++ 引用C 会出错,因为 上述的函数重载, C 默认的函数名为 _函数名,但是C++的函数名会发生变化,编译时映射表无法对应 所以C++ 引用C 的时候需要使用extern,告诉编译器 某些地方使用C编译 12345678910111213141516// sum.h#ifndef _SUM_H#define _SUM_H#if __cplusplusextern &quot;C&quot; &#123;#endif int sum(int a, int b);#if __cplusplus&#125;#endif#endif 12345678// sum.c#include &quot;sum.h&quot;int sum(int a, int b) &#123; return a + b;&#125; 注意: extern 可以修饰函数 extern &quot;C&quot; func () {} , 当函数申明和实现分离时,必须写在申明中,写在实现中会报错 默认参数函数可以带默认参数,但是默认参数的顺序是从右向左, 简单来说,左边的形参没有默认参数,右边就不能有; 左边的形参有了默认参数,左边第二个才可以设置默认参数 注意: 默认参数与函数的重载一起使用时,可能导致二义性 12345678910111213void func (int a , int b = 12) &#123;&#125;void fund (int a) &#123;&#125;// 调用下面的没问题func(10,20);// 调用下面的报错,二义性func(10); 函数指针123void func (int a, int b) &#123;&#125;void (*name)(int, int) = func OC Block的实现就是函数指针 实参和形参总结: 定义时 占位的参数 就是形参 调用时 实际赋值的参数 就是实参]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>游戏破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio Code 使用指南]]></title>
    <url>%2F2018%2F10%2F16%2FVisual%20Studio%20Code%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[篇首语:本文主要讨论的是 MAC 环境下的 VS Code 使用 本篇对应的 VS Code 版本是 1.28.2. 能力所限,了解的比较片面,讨论的也仅仅是 C++ 以及 C# (Unity)的使用,不足之处请指教或者留言. 为什么使用 VS Code优点: 轻量级, 扩展性强 缺点: 需要配置,提示貌似不是很及时 VS Code 安装https://visualstudio.microsoft.com/zh-hans/?rr=https%3A%2F%2Fwww.baidu.com%2Flink%3Furl%3DNAZso_MpT2UfyAFtJtoUVkbTE8io2_izLGJJ7zGZt2g3wh_LrRI2rn0BKwvvTLd9%26wd%3D%26eqid%3D9b6ead9600015c45000000025be7b062 C++ 使用使用插件安装插件 Shift + Command + X 跳转到扩展安装页面 搜索 C/C++ , 找到Microsoft 出品的插件,标题为C/C++ for Visual Studio Code 点击安装,然后点击重启以运行 搜索 Code Runner ,安装并重启 编写 C++ 程序, 按住 Control + option + n 以运行,但是目前是不支持 debug 的 CodeRunner 配置输出中无法编辑的问题描述: 默认 CodeRunner 是无法输入的 shift+cmd+p 打开 命令面板, 输入open user settings, 在右边的用户设置里面新增&quot;code-runner.runInTerminal&quot;: true, 自动保存文件在 .vscode 找到 setting.json, &quot;code-runner.saveFileBeforeRun&quot;: true, 每次提示已经CodeRunner 已经启动在 .vscode 找到 setting.json, &quot;code-runner.clearPreviousOutput&quot;: true, 使用本身Debug配置Shift + Command + D 跳转到 Debug 边栏,点击边栏上方的齿轮按钮,出现了launch.json ,这个就是启动的配置文件,我们需要配置这个文件 C/C++ 的基本信息配置shift + command + P 选择 C/C++: Edit configration 打开c_cpp_properties.json 文件 默认配置如下 123456789101112131415161718192021&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Mac&quot;, &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;/**&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;], &quot;macFrameworkPath&quot;: [ &quot;/System/Library/Frameworks&quot;, &quot;/Library/Frameworks&quot; ], &quot;compilerPath&quot;: &quot;/usr/bin/clang&quot;, &quot;cStandard&quot;: &quot;c11&quot;, &quot;cppStandard&quot;: &quot;c++17&quot;, &quot;intelliSenseMode&quot;: &quot;clang-x64&quot; &#125; ], &quot;version&quot;: 4&#125; name : 配置信息的唯一标志 includePath : 头文件的路径 macFrameworkPath : mac 的标准头文件路径 compilerPath : 编译地址的全路径 cStandard : C 标准 cppStandard : C++ 标准 intelliSenseMode : 环境场景模式 C++ 编译的配置文件Shift + command + P 选择 Tasks: Configure tasks, 选择其他的模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;Build&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;-Wall&quot;, &quot;-std=c++11&quot;, &quot;-lm&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot; ], &quot;windows&quot;: &#123; &quot;args&quot;: [ &quot;-g&quot;, &quot;-Wall&quot;, &quot;-std=c++11&quot;, &quot;-lm&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot; ] &#125;, &quot;presentation&quot;: &#123; &quot;reveal&quot;: &quot;always&quot;, &quot;echo&quot;: false, &quot;focus&quot;: true &#125;, &quot;problemMatcher&quot;: &#123; // 将错误信息匹配到`问题`中去 &quot;owner&quot;: &quot;cpp&quot;, &quot;fileLocation&quot;: &quot;absolute&quot;, &quot;pattern&quot;: &#123; &quot;regexp&quot;: &quot;^(.*):(\\d+):(\\d+):\\s+(error):\\s+(.*)$&quot;, &quot;file&quot;: 1, &quot;line&quot;: 2, &quot;column&quot;: 3, &quot;severity&quot;: 4, &quot;message&quot;: 5 &#125; &#125; &#125;, &#123; &quot;label&quot;: &quot;Run&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;dependsOn&quot;: &quot;Build&quot;, &quot;command&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;, &quot;windows&quot;: &#123; &quot;command&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot; &#125;, &quot;args&quot;: [], &quot;presentation&quot;: &#123; &quot;reveal&quot;: &quot;always&quot;, &quot;focus&quot;: true &#125;, &quot;problemMatcher&quot;: [], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;test&quot;, &quot;isDefault&quot;: true &#125; &#125; ]&#125; Debug 的配置文件launch.json123456789101112131415161718192021222324252627282930&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;c/c++ Debug&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;lldb&quot;, &quot;preLaunchTask&quot;:&quot;c++&quot; &#125;, &#123; &quot;name&quot;: &quot;(lldb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/a.out&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;MIMode&quot;: &quot;lldb&quot; &#125; ]&#125; 修改快捷键习惯使然,我习惯 cmd + R 运行, cmd + B 编译 shift + cmd + p 搜索 open keyboard shortcuts, 选择高级自定义,打开keyboardings.json 123456789101112[ &#123; &quot;key&quot;: &quot;cmd+b&quot;, &quot;command&quot;: &quot;workbench.action.tasks.runTask&quot;, // &quot;args&quot;: &quot;Run tests&quot;, &#125;, &#123; &quot;key&quot;: &quot;cmd+r&quot;, &quot;command&quot;: &quot;workbench.action.debug.run&quot; &#125;] C# 使用配合 Unity 使用搜索扩展 unity3d-pack, 安装. 需要等待安装其他东西一会儿.安装成功后 新建一个 unity 的C# 文件,在Start() 输入 gameObject 看有没有提示,如果没有提示,表明安装不完全,有错误 每次启动报错 1The reference assemblies for framework &quot;.NETFramework,Version=v3.5&quot; were not found. 安装环境检查 检查 openssl 是否安装 $ openssl version 检查 dotnet 是否安装 $ dotnet 检查 mono 是否安装正确 $ mono --version ,一般都是这里有问题 重新安装 $ brew install mono,如果安装过了 $ brew reinstall mono 如果网络不行,可以自行下载https://www.mono-project.com/download/stable/ Unity 调试运行 unity, 然后 运行VSCode Debug中的Unity Editer! Bingo!!! 存疑mac 版本的 vc code 运行 c++ 时, 总是打开外部终端,我想直接使用 vscode 集成终端,不知道怎么弄,希望大家给予帮助! 后续需要更新C++ 查看汇编 参考文档https://www.zhihu.com/question/30315894 https://www.imakewebsites.ca/posts/2017/02/11/unity3d-vscode-os-x-reference-assemblies-not-found-error/]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Unity</tag>
        <tag>C#</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 学习(三) 脚本]]></title>
    <url>%2F2018%2F10%2F16%2FUnity%20%E5%AD%A6%E4%B9%A0(%E4%B8%89)%20%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[创建模板右击创建一个脚本,脚本初始内容为: 123456789// Use this for initializationvoid Start () &#123; &#125; // Update is called once per framevoid Update () &#123; &#125; 但是我不想用这一套脚本怎么办? 创建自定义脚本方式1Mac 环境下, 找到Application/Unity, 显示包内容, 找到Contents/Resources/ScriptTemplates/ 可以看到有81-C# Script-NewBehaviourScript.cs.txt 之类的文本 这个就是右击Create的模板, 81 代表的是优先级 我们创建一个相同的文件,取名为81-My C# Script-NewBehaviourScript.cs.txt 内容如下 123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using UnityEngine;public class #SCRIPTNAME# : MonoBehaviour &#123; // Use this for initialization void Awake () &#123; #NOTRIM# &#125; // do not Use this for initialization void Start () &#123; #NOTRIM# &#125; // Update is called once per frame void Update () &#123; #NOTRIM# &#125;&#125; 到Unity中查看效果 缺点: 不利于团队合作,每个人都必须修改一次,而且这还修改了底层源文件,如果md5校验肯定通过不了 创建自定义模板方式2在 Assets 下创建 Editor 文件夹, 在 Editor 下创建ScriptTemplates 文件夹 Mac 环境下, 找到Application/Unity, 显示包内容, 找到Contents/Resources/ScriptTemplates/ 拷贝81-C# Script-NewBehaviourScript.cs.txt 到 ScriptTempletes 文件夹下,修改名称为C# Script-MyNewBehaviourScript.cs.txt,这个就是自己的模板 修改模板,可以随意修改 123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using UnityEngine;public class #NAME# : MonoBehaviour &#123; // 不依赖其他游戏物体的属性这里初始化 void Awake () &#123; &#125; // 需要依赖其他游戏物体的属性最好在这里初始化(保证物体已经创建好了) void Start () &#123; &#125; // 更新,每一帧调用 void Update () &#123; &#125;&#125; 在Assets/Editor 下创建 MyTool.cs文件 编辑内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192using UnityEngine;using UnityEditor;using UnityEditor.ProjectWindowCallback;using System;using System.IO;using System.Text.RegularExpressions;using System.Text;public class MyTool &#123; // 默认的文件地址 private const string My_Script_Default_Path = &quot;Assets/Editor/ScriptTemplates/C# Script-MyNewBehaviourScript.cs.txt&quot;; // MenuItem 参数1: 在哪里插入 参数2: 是否是验证合法的函数 参数3: 优先级,小于81就会在81之前展示 [MenuItem(&quot;Assets/Create/C# MyScript&quot;,false,80)] public static void CreateScript() &#123; // 获取目标地址 string locationPath = GetSelectedPathOrFallback(); // 根据源文件创建一个类 ProjectWindowUtil.StartNameEditingIfProjectWindowExists(0,ScriptableObject.CreateInstance&lt;MyDoCreateScriptAssets&gt;(),locationPath + &quot;/MyNewBehaviourScript.cs&quot;,null,My_Script_Default_Path); &#125; // 鼠标选择的获取地址,如果没有选择创建在 Assets 下 ,如果选择了 文件或者文件夹, 就在当前文件夹的目录 public static string GetSelectedPathOrFallback() &#123; string path = &quot;Assets&quot;; foreach (UnityEngine.Object item in Selection.GetFiltered(typeof(UnityEngine.Object),SelectionMode.Assets)) &#123; path = AssetDatabase.GetAssetPath(item); if (!string.IsNullOrEmpty(path) &amp;&amp; File.Exists(path)) &#123; path = Path.GetDirectoryName(path); break; &#125; &#125; return path; &#125;&#125;// 结束编辑文件名称调用的类class MyDoCreateScriptAssets: EndNameEditAction &#123; // 结束编辑文件名称调用的动作,标记ID , 存储地址, 来源地址 public override void Action(int instanceId, string pathName, string resourceFile) &#123; UnityEngine.Object obj = CreateScriptAssetFromTemplate(pathName,resourceFile); ProjectWindowUtil.ShowCreatedAsset(obj); &#125; // 核心代码 internal UnityEngine.Object CreateScriptAssetFromTemplate (string pathName, string resourceFile) &#123; string fullPath = Path.GetFullPath(pathName); Debug.Log(pathName+&quot;=====&quot;+fullPath+&quot;=======&quot;+resourceFile); // 1. 从模板读取文件 // 创建读取流 StreamReader fileRd = new StreamReader(resourceFile); // 获取文本 string text = fileRd.ReadToEnd(); // 关闭流 fileRd.Close(); // 2. 修改读取出的文件 // 获取到不包含扩展名的文件名 a.txt 获取到a string fileNameNoExtension = Path.GetFileNameWithoutExtension(pathName); // 将文件中所有的 #NAME# 替换成 写入的名称 text = Regex.Replace(text,&quot;#NAME#&quot;,fileNameNoExtension); // 3. 将修改好的文本写入目标位置 // 创建写入流 // 写入是新增还是替换,默认是替换 bool appending = false; // uft8 编码参数1 : 编码是否需要标记UTF8标识 bool encoderShouldEmitUTF8Identifier = true; // uft8 编码遇到错误字节 是否抛出 bool throwOnInvalidBytes = false; // 创建utf8 编码 UTF8Encoding encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier,throwOnInvalidBytes); // 根据uft8 编码创建 读取流 StreamWriter fileWt = new StreamWriter(fullPath,appending,encoding); // 写入 fileWt.Write(text); // 关闭流 fileWt.Close(); // 在pathName的位置加载文件 AssetDatabase.ImportAsset(pathName); return AssetDatabase.LoadAssetAtPath(pathName,typeof(UnityEngine.Object)); &#125;&#125; 序列化单例优化编译模块化编译错误日志记录]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 学习(四) UGUI]]></title>
    <url>%2F2018%2F10%2F16%2FUnity%20%E5%AD%A6%E4%B9%A0(%E5%9B%9B)%20UGUI%2F</url>
    <content type="text"><![CDATA[创建模板右击创建一个脚本,脚本初始内容为: 123456789// Use this for initializationvoid Start () &#123; &#125; // Update is called once per framevoid Update () &#123; &#125; 但是我不想用这一套脚本怎么办? 创建自定义脚本方式1Mac 环境下, 找到Application/Unity, 显示包内容, 找到Contents/Resources/ScriptTemplates/ 可以看到有81-C# Script-NewBehaviourScript.cs.txt 之类的文本 这个就是右击Create的模板, 81 代表的是优先级 我们创建一个相同的文件,取名为81-My C# Script-NewBehaviourScript.cs.txt 内容如下 123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using UnityEngine;public class #SCRIPTNAME# : MonoBehaviour &#123; // Use this for initialization void Awake () &#123; #NOTRIM# &#125; // do not Use this for initialization void Start () &#123; #NOTRIM# &#125; // Update is called once per frame void Update () &#123; #NOTRIM# &#125;&#125; 到Unity中查看效果 缺点: 不利于团队合作,每个人都必须修改一次,而且这还修改了底层源文件,如果md5校验肯定通过不了 创建自定义模板方式2在 Assets 下创建 Editor 文件夹, 在 Editor 下创建ScriptTemplates 文件夹 Mac 环境下, 找到Application/Unity, 显示包内容, 找到Contents/Resources/ScriptTemplates/ 拷贝81-C# Script-NewBehaviourScript.cs.txt 到 ScriptTempletes 文件夹下,修改名称为C# Script-MyNewBehaviourScript.cs.txt,这个就是自己的模板 修改模板,可以随意修改 123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using UnityEngine;public class #NAME# : MonoBehaviour &#123; // 不依赖其他游戏物体的属性这里初始化 void Awake () &#123; &#125; // 需要依赖其他游戏物体的属性最好在这里初始化(保证物体已经创建好了) void Start () &#123; &#125; // 更新,每一帧调用 void Update () &#123; &#125;&#125; 在Assets/Editor 下创建 MyTool.cs文件 编辑内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192using UnityEngine;using UnityEditor;using UnityEditor.ProjectWindowCallback;using System;using System.IO;using System.Text.RegularExpressions;using System.Text;public class MyTool &#123; // 默认的文件地址 private const string My_Script_Default_Path = &quot;Assets/Editor/ScriptTemplates/C# Script-MyNewBehaviourScript.cs.txt&quot;; // MenuItem 参数1: 在哪里插入 参数2: 是否是验证合法的函数 参数3: 优先级,小于81就会在81之前展示 [MenuItem(&quot;Assets/Create/C# MyScript&quot;,false,80)] public static void CreateScript() &#123; // 获取目标地址 string locationPath = GetSelectedPathOrFallback(); // 根据源文件创建一个类 ProjectWindowUtil.StartNameEditingIfProjectWindowExists(0,ScriptableObject.CreateInstance&lt;MyDoCreateScriptAssets&gt;(),locationPath + &quot;/MyNewBehaviourScript.cs&quot;,null,My_Script_Default_Path); &#125; // 鼠标选择的获取地址,如果没有选择创建在 Assets 下 ,如果选择了 文件或者文件夹, 就在当前文件夹的目录 public static string GetSelectedPathOrFallback() &#123; string path = &quot;Assets&quot;; foreach (UnityEngine.Object item in Selection.GetFiltered(typeof(UnityEngine.Object),SelectionMode.Assets)) &#123; path = AssetDatabase.GetAssetPath(item); if (!string.IsNullOrEmpty(path) &amp;&amp; File.Exists(path)) &#123; path = Path.GetDirectoryName(path); break; &#125; &#125; return path; &#125;&#125;// 结束编辑文件名称调用的类class MyDoCreateScriptAssets: EndNameEditAction &#123; // 结束编辑文件名称调用的动作,标记ID , 存储地址, 来源地址 public override void Action(int instanceId, string pathName, string resourceFile) &#123; UnityEngine.Object obj = CreateScriptAssetFromTemplate(pathName,resourceFile); ProjectWindowUtil.ShowCreatedAsset(obj); &#125; // 核心代码 internal UnityEngine.Object CreateScriptAssetFromTemplate (string pathName, string resourceFile) &#123; string fullPath = Path.GetFullPath(pathName); Debug.Log(pathName+&quot;=====&quot;+fullPath+&quot;=======&quot;+resourceFile); // 1. 从模板读取文件 // 创建读取流 StreamReader fileRd = new StreamReader(resourceFile); // 获取文本 string text = fileRd.ReadToEnd(); // 关闭流 fileRd.Close(); // 2. 修改读取出的文件 // 获取到不包含扩展名的文件名 a.txt 获取到a string fileNameNoExtension = Path.GetFileNameWithoutExtension(pathName); // 将文件中所有的 #NAME# 替换成 写入的名称 text = Regex.Replace(text,&quot;#NAME#&quot;,fileNameNoExtension); // 3. 将修改好的文本写入目标位置 // 创建写入流 // 写入是新增还是替换,默认是替换 bool appending = false; // uft8 编码参数1 : 编码是否需要标记UTF8标识 bool encoderShouldEmitUTF8Identifier = true; // uft8 编码遇到错误字节 是否抛出 bool throwOnInvalidBytes = false; // 创建utf8 编码 UTF8Encoding encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier,throwOnInvalidBytes); // 根据uft8 编码创建 读取流 StreamWriter fileWt = new StreamWriter(fullPath,appending,encoding); // 写入 fileWt.Write(text); // 关闭流 fileWt.Close(); // 在pathName的位置加载文件 AssetDatabase.ImportAsset(pathName); return AssetDatabase.LoadAssetAtPath(pathName,typeof(UnityEngine.Object)); &#125;&#125; 序列化单例优化编译模块化编译错误日志记录]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS常见访问地址]]></title>
    <url>%2F2018%2F10%2F15%2FiOS%E5%B8%B8%E8%A7%81%E8%AE%BF%E9%97%AE%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[appleID登录地址https://appleid.apple.com/ 苹果开发者账号https://developer.apple.com/account/#/overview/G9AP62BQZD 购买688元套餐地址https://developer.apple.com/enroll/cn 苹果上架App 管理地址https://appstoreconnect.apple.com/ 苹果iTunes下载地址https://itunes.apple.com/cn/genre/ios/id36?mt=8 苹果开源源码地址https://opensource.apple.com/tarballs/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 学习(二) 拓展编辑器]]></title>
    <url>%2F2018%2F10%2F15%2FUnity%20%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%20%E6%8B%93%E5%B1%95%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Unity 编辑器可以扩展,添加自己的需求 Unity扩展的相对路径 最好在 Assets/Editor文件夹下,因为Editor文件夹会自己编译成/Library/ScriptAssemblies/Assembly-CSharp-Editor.dll 文件, 打包时不会链接到最终的包中 窗口扩展在Assets创建一个Editor文件夹,文件夹里面放置的文件用作UnityEditor 的扩展 为什么要扩展? 比如将某个场景或者游戏物体保存为XML,但是Unity 没有提供方法,我们需要自己写 书写格式 [MenuItem(&quot;path&quot;,isValidateFunc,num)] 第一个参数 path 表明在哪里添加拓展,第二个参数 表明是否是验证过的方法第三个参数 表明是 优先级,多个在同级目录的时候有作用 Project 窗口扩展自定义右击123456789// MenuItem Assets 表明在Project 窗口目录下右击的列表中[MenuItem(&quot;Assets/My Tools/Tool1&quot;,false,1)]static void doSome1 () &#123; Debug.Log(&quot;Dosome1&quot;); // if (Selection.activeObject != null)&#123; Debug.Log(Selection.activeObject.name); &#125;&#125; 在右击的 create 目录下新增 Tool312345// 1000 就在列表的最下面[MenuItem(&quot;Assets/Create/Tool3&quot;,false,1000)]static void doSome2 () &#123; Debug.Log(&quot;Dosome2&quot;);&#125; 拓展布局: 选中的条目增加按钮1234567891011121314151617181920212223242526// 声明一旦初始化就调用的方法[InitializeOnLoadMethod]static void doSome4() &#123; // 所有可见列表项的 onGUI 事件触发的代理,相当于绘制一次一个物体就会调用一次 EditorApplication.projectWindowItemOnGUI = delegate(string guid, Rect sectionRect) &#123; // 如果选中物体 并且选中的物体是系统资源 if (Selection.activeObject &amp;&amp; guid == AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(Selection.activeObject)))&#123; float width = 50; float d = 1; sectionRect.x += (sectionRect.width - width); sectionRect.y += d; sectionRect.width = width; sectionRect.height -= (2 * d); // 以GUI红色创建一个Button GUI.color = Color.red; if (GUI.Button(sectionRect,&quot;Click&quot;))&#123; // 逻辑代码 Debug.LogFormat(&quot;click: &#123;0&#125;&quot;,Selection.activeObject.name); &#125; // GUI还原成白色,渲染之后的所有的控件,如果不设置后面所有的控件都是红色 GUI.color = Color.white; &#125; &#125;;&#125; 监听资源的变化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 首先创建一个继承自 `AssetModificationProcessor`的类public class UnityTool: UnityEditor.AssetModificationProcessor &#123; // 1. 如果只关心发生变化, 使用前两个函数 [InitializeOnLoadMethod] static void func1 () &#123; EditorApplication.projectChanged += dele; &#125; // static void dele () &#123; // 即将改变 &#125; // 2. 如果关心具体什么变化,直接后面的函数 // 资源即将被创建 public static void OnWillCreateAsset(string path) &#123; Debug.Log(&quot;create Asset in path: &quot; + path); &#125; // 即将双击打开文件,目前的问题是显示的是 meta 文件,2种可能: 1. 实际修改的就是 meta 2. 返回的有问题 public static bool IsOpenForEdit (string assetPath, out string message) &#123; message = null; // Debug.LogFormat(&quot;AssetPath: &#123;0&#125;&quot;,assetPath); return true; &#125; // 即将删除,可以控制磁盘上是否允许删除, 问题是 DidNotDelete 是允许删除 , DidDelete 是不允许删除 public static AssetDeleteResult OnWillDeleteAsset(string assetpath, RemoveAssetOptions opt) &#123; Debug.LogFormat(&quot;delete: &#123;0&#125;&quot;, assetpath); return AssetDeleteResult.DidNotDelete; &#125; // 即将移动,可以控制磁盘上是否移动, 问题是 DidNotMove 是允许移动 , DidMove 是不允许移动 public static AssetMoveResult OnWillMoveAsset(string oldPath, string newPath) &#123; Debug.LogFormat(&quot;允许moveFrom: &#123;0&#125; to : &#123;1&#125;&quot;, oldPath,newPath); return AssetMoveResult.DidNotMove; &#125; // 即将保存, 貌似只对Scene 的保存有反应 public static string[] OnWillSaveAssets(string[] path) &#123; if (path != null)&#123; Debug.LogFormat(&quot;Savepath: &#123;0&#125;&quot;,string.Join(&quot;,&quot;,path)); &#125; return path; &#125;&#125; Hierachy 窗口扩展自定义右击12345[MenuItem(&quot;GameObject/My Create/Cube&quot;,false,0)]static void doSome4 () &#123; GameObject.CreatePrimitive(PrimitiveType.Cube); Debug.Log(&quot;Dosome4&quot;);&#125; 拓展布局 : 选中的条目增加按钮1234567891011121314151617181920// 在一开始初始化就[InitializeOnLoadMethod]static void newInit () &#123; EditorApplication.hierarchyWindowItemOnGUI = delegate (int instanceId, Rect rect) &#123; if (Selection.activeObject &amp;&amp; Selection.activeObject.GetInstanceID() == instanceId)&#123; float width = 50; float height = 20; // 调整按钮的位置 rect.x += rect.width - width; rect.width = width; rect.height = height; // 创建按钮,设置按钮图标, 设置点击事件 if (GUI.Button(rect,AssetDatabase.LoadAssetAtPath&lt;Texture&gt;(&quot;Assets/timg.jpeg&quot;)))&#123; Debug.LogFormat(&quot;Click At: &#123;0&#125;&quot;,Selection.activeObject.name); &#125; &#125; &#125;;&#125; 右击使用自定义的列表1234567891011121314151617181920212223242526272829303132333435363738// 1. 准备好 方法列表[MenuItem(&quot;Window/Test/jixiao&quot;)]static void func1 () &#123; Debug.Log(&quot;func1&quot;);&#125;[MenuItem(&quot;Window/Test/momo&quot;)]static void func2 () &#123; Debug.Log(&quot;func2&quot;);&#125;[MenuItem(&quot;Window/Test/雨凇/mono&quot;)]static void func3 () &#123; Debug.Log(&quot;func3&quot;);&#125;// 2. 添加UI替换方法[InitializeOnLoadMethod]static void replace () &#123; EditorApplication.hierarchyWindowItemOnGUI += onHierachyGUI;&#125;// 3. 替换方法static void onHierachyGUI (int instanceID, Rect selectionRect) &#123; // 有事件发生,且是鼠标右键点击事件, 点击的位置在某个控件上, 当前的事件是鼠标右键弹起时 if (Event.current != null &amp;&amp; selectionRect.Contains(Event.current.mousePosition) &amp;&amp; Event.current.button == 1 &amp;&amp; Event.current.type &lt;= EventType.MouseUp) &#123; // 只有点到控件上才有效果 GameObject obj = EditorUtility.InstanceIDToObject(instanceID) as GameObject; if (obj)&#123; // 鼠标点击的位置 Vector2 mousePosition = Event.current.mousePosition; // 创建列表 EditorUtility.DisplayPopupMenu(new Rect(mousePosition.x,mousePosition.y,0,0),&quot;Window/Test&quot;,null); // 使用新的事件替代原来的鼠标事件,注释掉意味着执行完这里的代码还会继续执行系统的代码 Event.current.Use(); &#125; &#125;&#125; 重写某些功能2018 版本貌似不支持 拓展 Inspector 视图拓展原生组件修改Camera 1234567891011121314151617using UnityEngine;using UnityEditor;using UnityEngine.UI;// 修改的组件类型[CustomEditor(typeof(Camera))]public class MyEditor: Editor &#123; public override void OnInspectorGUI() &#123; if (GUILayout.Button(&quot;拓展按钮&quot;)) &#123; // 事件 Debug.Log(&quot;xxxx&quot;); &#125; // 继续绘制 base.OnInspectorGUI(); &#125;&#125; 拓展某些已经被重写但封装无法访问的组件12345678910111213141516171819202122232425using UnityEngine;using UnityEditor;using UnityEngine.UI;using System.Reflection; // 修改的组件类型[CustomEditor(typeof(Transform))]public class MyEditor: Editor &#123; private Editor m_Editor; void OnEnable() &#123; // 通过反射获取到方法 m_Editor = Editor.CreateEditor(target,Assembly.GetAssembly(typeof(Editor)).GetType(&quot;UnityEditor.TransformInspector&quot;,true)); &#125; // 绘制 public override void OnInspectorGUI () &#123; if (GUILayout.Button(&quot;拓展按钮&quot;)) &#123; Debug.Log(&quot;xxxxxxxxxx&quot;); &#125; m_Editor.OnInspectorGUI(); &#125;&#125; 组件不可编辑12345678910if (GUILayout.Button(&quot;拓展按钮&quot;))&#123; Debug.Log(&quot;xxxxxxxxxx&quot;);&#125;// 下面内容不可编辑GUI.enabled = false;m_Editor.OnInspectorGUI();// 下面内容开始可编辑GUI.enabled = true; 拓展Component的Context即右击某个组件时的下拉框 123456789[MenuItem(&quot;CONTEXT/Transform/New Context 1&quot;)]static void func3 (MenuCommand comm) &#123; Debug.Log(comm.context.name);&#125;[MenuItem(&quot;CONTEXT/Transform/New Context 2&quot;)]static void func4 (MenuCommand comm) &#123; Debug.Log(comm.context.name);&#125; 拓展Scene视图热键设置1234[MenuItem(&quot;Assets/HotKey %#d&quot;,false,0)]static void onDraw () &#123; Debug.Log(&quot;HotKey&quot;);&#125; 总结方法1[MenuItem(&quot;GameObject/My Create/Cube&quot;,false,0)] 声明在Unity IDE的什么地方添加东西 方法2[InitializeOnLoadMethod] 声明Unity IDE 一旦加载(保存)一次就会调用的方法 规律1在Project 中右击的列表其实就是最上方工具栏的 Assets列表 在Hireachy 中右击的列表其实就是最上方工具栏的 GameObject列表 所以我们实质上是给 工具栏里面添加属性 理解不清晰内容Center 和 Pivot 的区别在几个物体被包含的情况下,Pivot 这个物体集合的坐标点是外部父元素的坐标点, 如果是Center, 物体的坐标点就是所有物体的中心位置 多选时, Povot 以第一个元素作为坐标点, Center 以整体的中心作为坐标点 Global 和 Local 的区别旋转时, Local 的坐标系 会跟着旋转,Global 不会 坐标系 ISO 以及 Persp的区别ISO坐标系 是正交模式, 在Scene中查看游戏物体是远近大小一样, Persp坐标系 摄像头类似于人眼, 在Scene中查看游戏物体就和Game中一样,近大远小 但是调整这个不影响Game中 游戏物体的展示!!! 很多资料都没说这么重要的信息. 这个坐标系的作用应该是为了方便搭建地图使用的]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS App扫码下载]]></title>
    <url>%2F2018%2F10%2F14%2FiOS%20App%E6%89%AB%E7%A0%81%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[目标: 通过扫二维码下载App,可以通过蒲公英,也很简单明了,这里我们自己搭建服务器来支持扫码下载 自己搭建第一步 准备一个https的服务器本人是腾讯云的账户,搭建了https的环境 怎么搭建可以访问腾讯云 云+社区 开发者实验室 ,搜索ssl 第二步 打包,准备plist打包生成ipa包, 貌似只有在开发者账户里面的用户可以安装,其他用户最后校验失败会导致安装失败 准备plist12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;http://123.206.68.204:1111/maarrytask.ipa&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;false/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;false/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;安装过程显示图片&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;com.techotc.DigitSign&lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;1.0&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;packName&lt;/string&gt; &lt;key&gt;subtitle&lt;/key&gt; &lt;string&gt;副标题&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt; bundle-identifier 必须修改 title 必须修改,改成包名/或者修改名 bundle-version 最好也修改下 url 必须要修改,修改为域名下地址 display-image 一般需要修改为Logo的图片地址 上传到服务器本人上传到https的根目录 具体是/usr/share/nginx/html 通过mac的ssh远程拷贝过去 命令: scp /Users/yourname/Desktop/xxx.ipa root@123.206.68.xx:/usr/share/nginx/html/xx.ipa scp /Users/yourname/Desktop/xxx.plist root@123.206.68.xx:/usr/share/nginx/html/xx.plist 需要输入服务器root密码 配置修改将plist的url修改为https://yourdomain/xxx.ipa 测试直接访问 https://yourdomain/xxx.plist 检验是否可以直接访问 准备一个下载页面核心代码跳转的核心代码 1&lt;a href=&quot;itms-services://?action=download-manifest&amp;amp;url=https://yourdomain/xxx.plist&quot;&gt;点击下载&lt;/a&gt; 上传到服务器scp /Users/yourname/Desktop/download.html root@123.206.68.xx:/usr/share/nginx/html/download.html 生成二维码首先测试 https://yourdomain/download.html可以正常访问 使用草料二维码生成,也可以自己使用coreImage 直接使用蒲公英蒲公英内部的操作步骤和我以上差不多,不过他的前端页面做的比较好,而且包上传之后会进行解压,提取里面的有用信息,所以能展示APP 名称等信息 登录蒲公英, 点击立即上传,选择需要上传的包,可以使iOS的 ipa包,也可以是安卓的 apk包, 直接发布 注意点: 相同的bundle-identifier 对应的是同一个包,只会迭代,所以如果有相同标记但是不同环境包的时候,请准备多个蒲公英账号 二维码信息需要使用Safari 打开,才能直接下载 参考文档https://blog.csdn.net/pzlsun/article/details/52080491 https://blog.csdn.net/klshuo/article/details/50485038]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 学习(一)]]></title>
    <url>%2F2018%2F10%2F11%2FUnity%20%E5%AD%A6%E4%B9%A0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Unity 下载建议下载 个人版 https://store.unity.com/products/unity-personal?_ga=2.170905952.1914627832.1539259756-39692342.1530083881 Unity 启动 Unity 界面介绍 Unity 设置栏介绍Unity Unity PreferencesGeneral External Tool Color GI Cache 2D Cache Server File BuildSetting Asset 其他介绍坐标 Center和Pivot 需要有游戏物体的包含才会看出效果Center 以 父子游戏物体组成体的中心点坐标坐标点 Pivot 以 父物体的中心点作为坐标点 Global 和 Local 只有旋转时才会看到差别Global 坐标轴不会因为旋转而变化 Local 坐标轴会根据旋转而不断变化 其他 进阶定义自己的LayoutUnity默认有很多窗口,不同窗口的排布方式我们称之为Layout,在窗口的右上角 为了开发方便,我们可以自己调整窗口位置,如果窗口不小心关闭了,也别担心,到菜单栏的window 里面,可以再次点出来 我们选择自己喜欢的布局,然后点击右上角的layout,选择save lauout ,保存下自己的layout,取名随意,以后就可以使用自己的布局啦 删除Projects里面不需要的工程观察对应工程的目录地址,直接删除目录地址或者改变地址即可 查看package下载的地址MAC地址 /Users/{用户名}/Library/Unity/Asset Store-5.x Windows地址 C:\Users\{用户名}\AppData\Roaming\Unity\Asset Store-5.x 在Scenes中自由查看Mac 下如何开启开车模式, 如果使用触控板, 双指同时点击下去,通过 WASD 控制,3D下效果明显 Unity版本使用情况详解https://blog.uwa4d.com/archives/VersonAnalysis511.html]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端游戏开发分析]]></title>
    <url>%2F2018%2F10%2F10%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[现状分析公司现状项目结束后移动端会进入一段时间的休整期,有一定的时间和精力,公司的开发人员没有进行过游戏开发,不了解开发相关事项. 技术现状目前技术还未掌握,但是语言相关的基础已经有了,常见的游戏脚本语言有C / C++ , C# , javascript等 学习目的游戏包含了当前最新的计算机图形学,算法,数据结构等重点内容 市场现状游戏市场永远没有饱和,但是游戏是有寿命的,一般的单机游戏盈利寿命最长是半年,网络游戏也是需要通过不断更新新的内容来维持用户的新鲜感,才能延续下去 好的游戏寿命一般较长,差的游戏说不定刚出来就死了. 移动端游戏是新兴市场,游戏质量一般只要过关,总有人玩,但是必须要有人去刷榜,保持下载量 技术选型语言选择了解C/C++ 或者了解 C# 语言基本语法 工具选择Unity优点: 简单易用,支持3D,2D,功能全面,资料众多,前端游戏首选 缺点: 资源占用较大,渲染较差,内存管理欠缺 团队模式收费 移动端对渲染要求较低,所以一般优先选择Unity Cocos2d-x优点: 简单,易用, 免费 缺点: 提升到3D表现一般,过时,现在社区不活跃 百度百科显示Cocos2d-x 占据高低端市场 超过70%,但是那已经是2013年的数据,这几年Unity的表现十分抢眼,优先选择Unity UE4优点: 渲染优秀,内存优化好,占用资源适中,工具免费 缺点: 学习稍微困难,学习资源少,新增一个:mac跑起来编译好久😂 学习完Unity如果需要进阶,我们可以直接切换到UE4,渲染效果会提升非常大,有Unity的基础,UE4也会非常好学 资源选择建议淘宝直接购买资源,或者选择maya制作资源 maya 下载目录 http://www.ifunmac.com/2017/10/maya-2018-1/maya 学习目录 https://huke88.com/route/maya.html?sem=baidu&amp;kw=106402 建议分工策划:策划的事情需要很多文档 包括游戏的数据, 玩法, 关卡的难度, 通关的条件, 游戏的世界观等等 美术:美术可以有专门的人研究下maya 地图以及模型 需要有美工提供原图,或者淘宝购买原图,或者逆向别人的图 程序:程序人员都可以投入,程序是一个最终的产品成型过程]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 破解版下载]]></title>
    <url>%2F2018%2F10%2F10%2FUnity%20%E7%A0%B4%E8%A7%A3%E7%89%88%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[声明本文仅供技术交流,没有任何商业目的. 针对人群mac 环境下的Unity 开发人员 破解版步骤首先下载Unity 官方版本目前试验支持的版本到2018.2.15f1https://unity3d.com/cn/get-unity/download/archive 按照步骤一直下一步安装成功即可,先不要打开 下载破解软件链接:https://pan.baidu.com/s/1_IKsotfeoSQhxMUMy7LGVA密码:787v 下载后打开,如图所示 到应用程序 里面找到Unity, 拖动到上面针筒的位置,然后点击+号. 然后，点击破解工具的工具栏：Tools-&gt;Copy Unity License files。破解完成。 参考文档http://www.ceeger.com/forum/read.php?tid=23396&amp;fid=8&amp;page=1]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Unity破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode9 如何支持iOS 12设备调试]]></title>
    <url>%2F2018%2F10%2F10%2FXcode9%20%20%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81iOS%2012%E8%AE%BE%E5%A4%87%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[步骤Xcode9 不支持 iOS 12 调试是因为缺少对应的调试包 支持设备的调试包 目录为/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 可以在Finder 中 通过shift + command + G, 键入上述地址进行快速定位 下载iOS 12 的调试包,安装到上述目录即可 资源链接: https://pan.baidu.com/s/1RBHQPQ_VWfGtOgnCRlvqFQ 提取码: rjr4 分享以后同样可以下载最新的Xcode 提取出对应的调试包,放置到旧款的Xcode即可]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Command</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode Command工具开发]]></title>
    <url>%2F2018%2F10%2F10%2FXcode%20Command%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[目标: 编写一个swift语言的命令行工具,用于识别回文以及异构词 创建swift的CommandLineTool工程shift + command + N 选择 macOS -&gt; Application -&gt; Command Line Tool Swift 没有了传统的main 函数,但是有一个main.swift文件, main函数被隐藏了 创建命令行的输出通常命令行工具会将 执行的命令,标准的输出,错误信息打印在控制台 错误信息也会以特殊颜色展示在控制台,我们先编写一个输出流的打印工具 创建一个swift 文件, 名称为ConsoleIO.swift 内容填充如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// ConsoleIO.swift// FindPhone//// Created by WilliamJi on 2018/10/10.// Copyright © 2018年 WilliamJi. All rights reserved.// 基本输出工具类import Foundation// 输出类型enum OutputType &#123; case error case standard&#125;// 输出class ConsoleIO: NSObject &#123; // 输出信息,输出内容,和类型 // .standard选项使用print,会写入到stdout. .error选项会使用c函数fputs写入信息到全局并且指向标准错误流的stderr public func writeMessage(_ message: String, to: OutputType = .standard) &#123; switch to &#123; case .standard: print(&quot;\(message)&quot;) case .error: fputs(&quot;Error: \(message)\n&quot;, stderr) &#125; &#125; // 打印基本的信息 public func printUsage() &#123; let executableName = (CommandLine.arguments[0] as NSString).lastPathComponent writeMessage(&quot;usage:&quot;) writeMessage(&quot;\(executableName) -a string1 string2&quot;) writeMessage(&quot;or&quot;) writeMessage(&quot;\(executableName) -p string&quot;) writeMessage(&quot;or&quot;) writeMessage(&quot;\(executableName) -h to show usage information&quot;) writeMessage(&quot;Type \(executableName) without an option to enter interactive mode.&quot;) &#125; &#125; 创建一个执行类创建一个MainTask.swift, 填充内容如下 123456789101112131415161718//// MainTask.swift// FindPhone//// Created by WilliamJi on 2018/10/10.// Copyright © 2018年 WilliamJi. All rights reserved.// 工具的主要逻辑import Foundationclass MainTask &#123; let cons = ConsoleIO() func run() &#123; cons.printUsage() &#125; &#125; 在main.swift中执行 MainTask().run() 命令行参数一般命令行后面的参数分为两种: 一种是类似于 -p 的option属性,一种是string内容信息 首先设置option枚举类型12345678910111213141516171819202122// 选项卡枚举enum OptionType:String &#123; // 回文 case palindrome = &quot;p&quot; // 检测变位字 case anagram = &quot;a&quot; // 帮助 case help = &quot;h&quot; // 其他 case unknown // 创建枚举 init(value: String) &#123; switch value &#123; case &quot;a&quot;: self = .anagram case &quot;p&quot;: self = .palindrome case &quot;h&quot;: self = .help default: self = .unknown &#125; &#125; &#125; 修改MainTask.swift新增读取字符串option转换为枚举的方法 1234// 根据选项的字符串,返回一个元组,包括变换的枚举和本身 func getOption(_ option: String) -&gt; (option:OptionType, value: String) &#123; return (OptionType(value: option), option) &#125; 修改run方法 12345678910111213141516func run() &#123;// cons.printUsage() // 1. 获取参数的个数 let argc = CommandLine.argc // 2. 获取第1个参数 let argv1 = CommandLine.arguments[1] // 3. 获取option let (option,value) = getOption(argv1.replacingOccurrences(of: &quot;-&quot;, with: &quot;&quot;)) // 4. 打印option的内容和枚举 cons.writeMessage(&quot;Argument count: \(argc) Option: \(option) value: \(value)&quot;) &#125; 在main.swift中添加判断 12345if CommandLine.argc &lt; 2 &#123; //TODO: 少于2个参数开启交互模式&#125;else &#123; MainTask().run()&#125; 测试找到product中的mach-o 文件Test, open in finder查看,在终端下输入 ./Test -a 或者 在 Edit Scheme Run 中的 Arguments 的 Argument Passed On Launch 点击 + 号,新增一个参数 -p ,直接运行xcode即可 回文和变位词什么是回文: 回文就是从前往后和从后往前读都是一样的次 比如 noon level 什么是变位词 就是用其他的词里面每个字母变换位置获得的新词 silent &lt;-&gt; listen 我们需要检测回文和变位词新增一个StringExtension.swift类 1234567891011121314151617181920212223242526272829//// StringExtension.swift// FindPhone//// Created by WilliamJi on 2018/10/10.// Copyright © 2018年 WilliamJi. All rights reserved.// 字符串的扩展import Foundationextension String &#123; // 检测回文 func isPalindrome() -&gt; Bool &#123; // 小写去空格 let old = self.lowercased().replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;) let new = String(old.reversed()) return old == new &#125; // 检测是否是异构词 func isAnagramOf(_ s: String) -&gt; Bool &#123; // 获取旧词的无空格小写内容 let old = self.lowercased().replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;) // 获取新词的无空格小写内容 let new = s.lowercased().replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;) // 重新排序并比较 return old.sorted() == new.sorted() &#125;&#125; 修改run方法12345678910111213141516171819202122232425262728293031323334353637383940414243 // 4. 打印option的内容和枚举// cons.writeMessage(&quot;Argument count: \(argc) Option: \(option) value: \(value)&quot;) // 4. 检测回文和构词法 switch option &#123; case .palindrome: // 检测回文 if argc != 3 &#123; if argc &gt; 3 &#123; cons.writeMessage(&quot;参数过多&quot;, to: .error) &#125;else&#123; cons.writeMessage(&quot;参数过少&quot;, to: .error) &#125; cons.printUsage() &#125;else &#123; let s = CommandLine.arguments[2] cons.writeMessage(&quot;\(s) \(s.isPalindrome() ? &quot;&quot; : &quot;不&quot;)是回文&quot;) &#125; break case .anagram: if argc != 4 &#123; if argc &gt; 4 &#123; cons.writeMessage(&quot;参数过多&quot;, to: .error) &#125;else&#123; cons.writeMessage(&quot;参数过少&quot;, to: .error) &#125; cons.printUsage() &#125;else&#123; let str1 = CommandLine.arguments[2] let str2 = CommandLine.arguments[3] cons.writeMessage(&quot;\(str2)\(str1.isAnagramOf(str2) ? &quot;&quot; : &quot;不&quot;)是\(str1)的异构词&quot;) &#125; break case .help: cons.printUsage() break default: cons.writeMessage(&quot;未知的参数&quot;) cons.printUsage() break &#125; 测试下方法同上 交互式获取内容12345678910111213// 输入提示内容,获取输入信息 func getInput(msg:String) -&gt; String &#123; // 0. 输出内容 self.writeMessage(msg) // 1. 获取键盘 let keyboard = FileHandle.standardInput // 2. 键盘获取的值 let inputData = keyboard.availableData // 3. 解析 let strData = String(data: inputData, encoding: String.Encoding.utf8)! // 4. 移除换行返回文字 return strData.trimmingCharacters(in: CharacterSet.newlines) &#125; 逻辑添加OptionType枚举中新增一个quit case quit = &quot;q&quot; 在init方法中新增 case &quot;q&quot;: self = .quit 在MainTask.swift新增函数 123456789101112131415161718192021222324252627func interactiveMode() &#123; cons.writeMessage(&quot;欢迎使用本系统,本系统检测回文以及异构体&quot;) var isFinish = false while !isFinish &#123; let (opt,val) = getOption(cons.getInput(msg: &quot;输入a 检测异构体, 输入p 检测回文,输入q 退出&quot;)) switch opt &#123; case .anagram: let fir = cons.getInput(msg: &quot;输入第一个单词&quot;) let sec = cons.getInput(msg: &quot;输入第二个单词&quot;) cons.writeMessage(&quot;\(fir)和\(sec) \(fir.isAnagramOf(sec) ? &quot;&quot; : &quot;不&quot;)是异构体&quot;) break case .palindrome: let value = cons.getInput(msg: &quot;请输入单词&quot;) cons.writeMessage(&quot;\(value)\(value.isPalindrome() ? &quot;&quot; : &quot;不&quot;)是回文&quot;) break case .quit: isFinish = true break default: cons.writeMessage(&quot;Unknown option \(val)&quot;, to: .error) break &#125; &#125; &#125; 打印字体颜色转变我们需要err的打印文字是红色的 修改两个case 123456case .standard: print(&quot;\u&#123;001B&#125;[;m\(message)&quot;) breakcase .error: fputs(&quot;\u&#123;001B&#125;[0;31m\(message)\n&quot;, stderr) break 字体颜色汇总待续…]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Command</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[越狱开发(一)-准备]]></title>
    <url>%2F2018%2F09%2F30%2F%E8%B6%8A%E7%8B%B1%E5%BC%80%E5%8F%91-%E4%B8%80-%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[什么是越狱,为什么越狱越狱即获取到手机的root权限,能够自由的安装和修改App,学习底层的相关知识 越狱的分类完美越狱和不完美越狱 不完美越狱 的不完美之处在于 不能关机! 关机之后需要重新越狱 完美越狱 只要不白苹果,不需要重新越狱 越狱手机准备越狱必须要有特定的设备,越狱是通过系统或者硬件的漏洞来获取超级权限,硬件的漏洞比较严重,硬件漏洞iOS更新到几都可以完美破解,目前就iPhone 3GS 是硬件漏洞 手机哪里买? 所有的二手手机商! 以上是废话,我实在360同城帮买的 如果需要筛选出自己的想要的iPhone(比如指定版本,指定手机类型,价格低于等,需要使用以下脚本) &lt;稍后补上&gt; 12 越狱待补充 Cydia介绍待补充 插件下载待补充 系统备份(重要)待补充 禁止更新待补充 小试身手要求: 将微信的Badge 设置为0 待补充]]></content>
      <categories>
        <category>越狱</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>越狱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSharp学习二]]></title>
    <url>%2F2018%2F09%2F21%2FCSharp%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSharp学习一]]></title>
    <url>%2F2018%2F09%2F20%2FCSharp%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[安装Visual Studio Code优点: 轻量级 官网下载最新版本 https://code.visualstudio.com/ .Net 和 C#.Net 一是指 微软提供的一整套平台, 二是指具体的.net.framework 运行库 C# 是依赖于net.framework的语言 Mac环境下 VS如何运行C#下载库dot net core 安装运行. 按照步骤一步步来即可 遇到的问题 运行下载下来的pkg文件报错,错误信息com.apple.installer.pagecontroller 错误 -1 包的签名有问题,https://www.microsoft.com/net/learn/get-started-with-dotnet-tutorial#macos Downloads 页面下载的包有问题 提示删除,非法来源 系统偏好设置.安全性与隐私.允许从以下位置下载的应用 选择任何来源 如果没有任何来源 字样 ,终端输入sudo spctl --master-disable 其他下载直接下载二进制包 下载包 https://www.microsoft.com/net/download/thank-you/dotnet-sdk-2.1.402-macos-x64-binaries 提取二进制文件以及依赖文件 dotnet 以及依赖host文件夹拷贝到/usr/local/bin/下,并且修改权限 chmod 777 dotnet 下载mono下载mono. mono 是.net跨平台的一套开源的微软.net全平台框架 https://www.mono-project.com/download/stable/ Hello World!重启命令行 dotnet new console -o myApp &amp; cd myApp dotnet run 配置VC Code终端控制台打印我运行调试的时候,终端和控制台来回打开,并且输入是,终端和控制台都无法接收输入信息 点击调试按钮旁边的齿轮, 出现launch.json 找到console 修改参数为 integratedTerminal 即可 参考文档在mac上使用VS Code编写C#应用程序https://www.jianshu.com/p/d8f63e1aef08 在mac上运行 mono https://blog.csdn.net/xzx_kag/article/details/78445894]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 开始写笔记]]></title>
    <url>%2F2018%2F09%2F20%2FHexo-%E5%BC%80%E5%A7%8B%E5%86%99%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[如何本地存储图片我们写博客有时候需要很多图片,如果有可能可以选择网络图片,但是免费的网络图片随时可能失效(1年之后可能就失效了,文章就废了),自己的对象存储是按照流量收费,并且是后付费的(如果找到免费的,推荐) 我们选择本地存储图片试试! 在hexo目录下运行 npm install hexo-asset-image --save 下载依赖 修改站点配置文件_config.yml 修改如下 12# post 可以添加图片post_asset_folder: true 对以前的文件添加同名目录,图片放在目录下即可方便引用 首页隐藏一些文章我们有时候需要首页隐藏一些文章,但是又可以搜索的到,人真是矛盾的生物啊… 怎么做呢,我们替换一下首页生成的工具 12$ npm install hexo-generator-index2 --save$ npm uninstall hexo-generator-index --save 找到 hexo 的配置文件_config 配置index_generator 条目,修改如下 12345678# index2 generator是否包含官方的hexo-generator-index，默认true（包含）index2_include_index: trueindex2_generator:per_page: 8 # 每页展示文章数order_by: -date # 按发布时间排序exclude: # 产生首页时忽略的文章, tag 包含 hide 或者 category 为 hide 的文章- tag hide # 不包含标签为hide的文章- category hide # 不包含分类为hide的文章 如果我想其他人完全看不到怎么办? 有两种办法,选其一: 设置密码 将_post里需要隐藏的文章 移动到 _draft中. 重新生成部署即可. 如何添加音乐和视频这里分为两种,一种是没有背景音乐,但是某些文章配置音乐(推荐!) 还有一种是设置背景音乐,一打开博客就是音乐很吵哎,不推荐! 添加背景音乐直接在文章中添加下列代码, 到网易云音乐中找到喜欢的音乐,生成外链 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=298 height=52 src=&quot;http://music.163.com/outchain/player?type=2&amp;id=32192436&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt; 到Next 主题目录 下的 layout 找到需要添加音乐的部分添加以上代码 比如要在侧边栏添加,修改 layout/_macro/sidebar.swig 文件,在适当的位置添加代码 注意: width 或者 height 设置为0可以隐藏音乐的展示层,但是音乐依然播放. 给某些文章添加背景音乐安装插件npm install --save hexo-tag-aplayer 修改hexo 配置文件,添加下列代码12aplayer: meting: true 获取音乐meting 的简单书写格式为 1&#123;% meting &quot;id&quot; &quot;server&quot; &quot;type&quot; %&#125; 例如 1&#123;% meting &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; %&#125; server支持的音乐平台有: netease, tencent, kugou, xiami, baidu,注意修改参数 歌曲的 id 和 type 必须对应,如果 id 是列表的 id, 那么 type 写上 playlist ,如果 id 是单曲, type 就是 song 打开QQ 音乐,找到喜欢的歌单,找到分享,选择复制链接https://y.qq.com/n/m/detail/taoge/index.html?id=5311096383,里面会有 id 5311096383, 替换到meting 中的 id,平台选择tencent , type 是 playlist 修改文章的 markdown添加下列代码 1&#123;% meting &quot;5311096383&quot; &quot;netease&quot; &quot;playlist&quot; &quot;mini&quot; &quot;listfolded&quot; %&#125; 说明 mini 是开启迷你模式, listfolded 是折叠列表 只想添加本地音乐怎么办使用标准的模式: console.error("Error: [hexo-tag-aplayer] Specified asset file not found ([picture_url,)"); 需要配合Hexo 的 文章资源文件夹 功能时,资源如 caffeine.mp3 picture.jpg ,caffeine.txt 放到文章的同名目录内 在需要的文章中添加 1&#123;% aplayer &quot;Caffeine&quot; &quot;Jeff Williams&quot; &quot;caffeine.mp3&quot; &quot;picture.jpg&quot; &quot;lrc:caffeine.txt&quot; %&#125; 给文章添加视频安装插件npm install hexo-tag-dplayer --save 找到视频这里只能是 http://xxxx/xxx/xx.mp4 书写格式no url specified, no dplayer _(:3」∠)_ 举例 1&#123;% dplayer &quot;url=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.mp4&quot; &quot;addition=https://dplayer.daoapp.io/bilibili?aid=4157142&quot; &quot;api=https://api.prprpr.me/dplayer/&quot; &quot;pic=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.jpg&quot; &quot;id=9E2E3368B56CDBB4&quot; &quot;loop=yes&quot; &quot;theme=#FADFA3&quot; &quot;autoplay=false&quot; &quot;token=tokendemo&quot; %&#125; 优酷,腾讯的视频如何引入搜索视频,分享,找到关于 iframe 的代码,复制代码,拷贝到文章中,但是貌似不能放在最后 可以加上长宽 1&lt;iframe frameborder=&quot;0&quot; src=&quot;https://v.qq.com/txp/iframe/player.html?vid=p0758s8f29d&quot; width=&quot;600&quot; height=&quot;500&quot; allowFullScreen=&quot;true&quot;&gt;&lt;/iframe&gt; 参考文档https://github.com/MoePlayer/hexo-tag-aplayer https://github.com/MoePlayer/hexo-tag-dplayer https://github.com/CodeFalling/hexo-asset-image http://blog.fiftykg.com/hexo/hexo%E9%A6%96%E9%A1%B5%E9%9A%90%E8%97%8F%E9%83%A8%E5%88%86%E6%96%87%E7%AB%A0.html]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo实用工具]]></title>
    <url>%2F2018%2F09%2F18%2FHexo%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Cyberduck远程服务器连接工具 优点: 文件目录形式,比命令行直观 远程连接快速,可以添加书签快速登录 可以使用sublime编辑文件,实时保存 可以同时连接命令行,作为图形化操作的补充 可以查看log 简单好用的markdown图床工具https://www.jianshu.com/p/e46a91ae20b9 快速生成图片链接 所有云的对象存储也可以生成实现图片链接,但是有额度限制,超出收费]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT主题优化2]]></title>
    <url>%2F2018%2F09%2F13%2FHexo%20NexT%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%962%2F</url>
    <content type="text"><![CDATA[添加音乐登录 网易云音乐, 找到喜欢的音乐或者歌单,点击 生成外链播放器, 选择iframe 插件 选择 尺寸 , 播放模式, 复制html 代码,然后粘贴到你需要的文件中 比如我希望在侧栏的Links后面,所以粘贴到的位置是 /hexo/themes/next/layout/_macro/sidebar.swig 找到如下代码,粘贴在后面 123&#123;% include &apos;../_custom/sidebar.swig&apos; %&#125; &lt;/div&gt; &lt;/section&gt; Hexo 添加封面这里只讨论拥有服务器,和域名的情况 修改博客的域名解析为 blog.youdomain.com 在自己的服务器部署nginx,添加www的域名解析指向nginx,具体步骤可以看下面的网址 https://cloud.tencent.com/developer/labs/lab/10068 nginx 默认的地址是 usr/share/ngin/html/ 只需要修改index.html即可 里面的图片可以到http://fontawesome.dashgame.com/中查找,在前面加上fa_前缀即可 1&lt;i class=&quot;fa fa-youtube-play vhm-item&quot;&gt;&lt;/i&gt; 效果查看https://www.williamlovealisa.cn]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT主题优化]]></title>
    <url>%2F2018%2F09%2F12%2FHexo%20NexT%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[NexT 文档写的很好,如果有兴趣可以看看 本文的站点配置目录为 /hexo/_config.yml 主题配置目录为 /hexo/themes/next/_comfig.yml 首先安装主题安装主题12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 1theme: next 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证主题启动本地站点hexo s, 访问http://0.0.0.0:4000/ 切换主题的风格NexT 提供了三种风格方案(Scheme) Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 修改/themes/next/_config.yml文件中的Scheme, 选择需要的样式去掉# 123#scheme: Musescheme: Mist#scheme: Pisces 基本设置设置语言到站点配置文件,即hexo/_config.yml文件修改 1language: zh-Hans # 简体中文 修改中文名 到themes/next/languages/zh-Hans.yml 修改对应的中文 侧栏 设置侧栏的位置 12sidebar: position: left # 左侧显示 right 显示侧栏显示的时机，修改 sidebar.display 的值 12345sidebar:# always 在所有页面展示# hide 在所有页面隐藏# remove 完全消失 display: post # 在文章页面展示 头像修改theme/next/_config.yml 12345678# 完整URIavatar: http://example.com/avatar.png# 放到theme/next/source/images下avatar: /images/avatar.png# 放到theme/next/source/images下 作者昵称修改外层 _config.yml, 将 author 修改为你的昵称 站点描述修改外层 _config.yml, 将 description 修改为你喜欢的签名 关于图标所有图标的来源https://fontawesome.com/ 用法来源:http://fontawesome.dashgame.com/ 具体地址在themes/next/source/lib/font-awesome/ 下 导航栏标题和图片1234567891011121314# 导航栏条目,如果有新的条目要新增,在这里添加, || 后面是图标,图标参考上面的&lt;关于图标&gt;menu: home: / || home # 前面地址,后面是图标 tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 然后新建tags, categories 以及about 页面 命令行分别输入下面三行,生成三个页面 123$ hexo new page tags$ hexo new page categories$ hexo new page about tags、categories页面需要设置类型 修改/hexo/source/tags/index.md 1234567---title: Tagsdate: 2017-09-07 17:17:32type: &quot;tags&quot;comments: false--- 修改/hexo/source/categories/index.md 1234567---title: categoriesdate: 2017-09-07 17:17:48type: &quot;categories&quot;comments: false--- about页面自己设置自我介绍,可以是个人简历等,自行编写markdown 公益404404 时帮助寻找失散的儿童,效果如下https://blog.williamlovealisa.cn/2018/09/12/Hex 使用方法，新建 404.html 页面，放到主题的 source 目录下，内容如下 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;回到我的主页&quot;&gt; &lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 集成RSSRSS是什么?RSS是站点用来和其他站点之间共享内容的一种简易方式,他剔除掉无用内容,将有用的内容聚合成XML,便于分享 怎么做?首先安装依赖包,命令行输入 1$ npm install hexo-generator-feed --save 修改站点配置文件_config.yml 123456feed: # RSS订阅插件 type: atom path: atom.xml limit: 0plugins: hexo-generate-feed 修改主题配置文件_config.yml 1rss: /atom.xml 在Hexo根目录重新运行, 1$ hexo g -d 首页不显示全文有必要么非常有必要,除非你想所有的文本都展示到首页,那么首页将非常臃肿,内容太多,首页内容只需要简介即可 怎么做?修改主题配置目录 1234# 首页仅仅显示缩略内容,限制150个字符auto_excerpt: enable: true length: 150 首页本篇文章分块阴影打开 \themes\next\source\css\_custom\custom.styl 添加内容 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 博客底部内容修改 12345678910111213141516171819202122232425# 博客底部显示内容footer: # Specify the date when the site was setup. # If not defined, current year will be used. # 创建该博客的时间,可以随意指定 since: 2018 # Icon between year and copyright info. # 博客版权信息之间的图标,这个是 ❉ 的图标 icon: snowflake-o # If not defined, will be used `author` from Hexo main config. # 版权,默认是博客的作者 copyright: # --------- # Hexo link (Powered by Hexo). # 显示Hexo强力驱动的信息,用了人家东西还是要讲点道德的... powered: true # 显示主题,主题的显示样式, 以及主题的版本号 theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: true 添加本地搜索功能在hexo 根目录,安装本地搜索 1$ npm install hexo-generator-searchdb --save 在站点配置文件 修改如下 123456#站内搜索search: path: search.xml field: post # 只搜索post类型的文件 format: html limit: 10000 # 最多10000条 在主题配置文件 修改如下 12345678910# Local search# Dependencies: https://github.com/flashlab/hexo-generator-search# 本地搜索local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 添加侧边栏的社交链接修改主题配置目录 123456789101112131415161718192021# 这里都是自己不同平台的账号social: # 我的博客地址链接 GitHub: https://github.com/JXwilliamJi || github Coding: https://coding.net/u/Fastlane || random 简书: https://www.jianshu.com/u/a2e80deb11a1 || book CSDN: https://blog.csdn.net/qq_31092987 || rotate-right #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk StackOverflow: https://stackoverflow.com/users/8341797/william-ji || stack-overflow Segmentfault: https://segmentfault.com/u/feiyuqingcheng || facebook E-Mail: mailto:jxjmdx2009@163.com || envelope #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram # Skype: mailto://yourname?call|chat || skypesocial_icons: enable: true icons_only: false transition: false 修改侧边栏友情链接修改 主题配置目录 12345678910111213141516# Blog rolls 博客其他资料,其他人的链接links_icon: link # 图标links_title: Links # 标题名字#links_layout: blocklinks_layout: inline # 行内样式links: # 具体链接,格式如下 #Title: http://example.com/ iOS免费书籍资料: https://github.com/justjavac/free-programming-books-zh_CN 创造狮导航: http://www.chuangzaoshi.com/code 前端导航: http://www.alloyteam.com/nav/ 掘金酱: http://e.xitu.io/ Arduino: https://www.arduino.cn/ 树莓派: https://www.raspberrypi.org/ MacApp免费下载: https://www.waitsun.com/ MacApp会员制下载: http://www.ifunmac.com/ 微信支付宝打赏功能从微信/支付宝获取自己的二维码截图,编辑成合适大小,周边不留白 将图片放置到next主题下的source/images/ 下 修改 主题配置文件 1234# Reward 打赏功能reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/Weichat.pngalipay: /images/AliPay.png 打赏功能修改,取消不停的抖动,改为抖动3次 打开 themes/next/source/css/_common/components/post/post-reward.styl 修改微信支付宝的样式如下 12345678910#wechat:hover p&#123; animation: roll 0.1s 3 linear; -webkit-animation: roll 0.1s 3 linear; -moz-animation: roll 0.1s 3 linear;&#125;#alipay:hover p&#123; animation: roll 0.1s 3 linear; -webkit-animation: roll 0.1s 3 linear; -moz-animation: roll 0.1s 3 linear;&#125; 第三方配置加速服务修改主题配置目录 的 vendors 属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# mquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: //cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: //cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js fancybox_css: //cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: //cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: //cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: //cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: //cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: //cdn.jsdelivr.net/ua-parser.js/0.7.10/ua-parser.min.js # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: //maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: //cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js 访客统计和文章阅读量不蒜子统计修改 主题配置目录 123456789101112131415161718192021# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/# 显示每个文章的访问人数 ,卜算子busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site # 效果：本站访客数12345人次 site_uv: true site_uv_header: 本站访客数 site_uv_footer: 人次 # 效果：本文总阅读量12345次 # custom pv span for the whole site site_pv: false site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; site_pv_footer: 人次 # custom pv span for one page only page_pv: true page_pv_header: 本文总阅读量 page_pv_footer: LeanCloud统计数据比较靠谱,待续 文章字数统计修改主题配置目录 123456789# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcount# 字符统计功能post_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true 修改 \themes\next\layout\_macro\post.swig 找到 &lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt; 添加内容,最终代码如下 12345&#123;% endif %&#125; &lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;span&gt; 如果同时要在文章底部统计全站字数 修改 /themes/next/layout/_partials/footer.swig 找到 post-meta-divider 后面添加内容,最终代码如下 123456&lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;div class=&quot;theme-info&quot;&gt; &lt;span class=&quot;post-count&quot;&gt;Total Words:&#123;&#123; totalcount(site) &#125;&#125;&lt;/span&gt;&lt;/div&gt;&#123;% endif %&#125; 直接修改不会展示 需要安装下包 1$ yarn add hexo-wordcount OR 1$ npm i --save hexo-wordcount 添加评论新增评论模块综合比较,不需要用户登录的只有leancloud https://valine.js.org/hexo.html 基于 leancloud,已经集成进来了 修改 主题配置文件 12345678910valine: enable: true appid: tHQNEE9Bi6ywV3plQQE5XVEg-gzGzoHsz appkey: WEMokMM90vN6Jpw7R1r2tqNz notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: true # 是否有验证码校验 placeholder: ヾﾉ≧∀≦)o 来呀！快活呀！~ # 默认文字 avatar: mm # gravatar style # 默认头像 guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 选择性关闭评论在 title 和 tag的同级目录添加如下,关系评论 comments: false 更优的做法是: 在scaffolds/post.md 以及 scaffolds/draft.md 文件下新增 comments: true,默认新增的post和draft都是支持评论的,且都有comments属性 站点顶部的加载条在 主题配置目录 搜索 pace,修改如下 1234567891011121314151617181920# Progress bar in the top during page loading.# 加载条,各种样式可选pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx # 模仿mac#pace-theme-minimal # 加载的是一条细线# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal 修改文章链接的样式修改themes\next\source\css\_common\components\post\post.styl ,在文章末尾添加CSS 样式如下 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 修改文章底部的标签样式修改 /themes/next/layout/_macro/post.swig 找到rel=&quot;tag&quot;&gt;# 修改为rel=&quot;tag&quot;&gt;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 文章底部添加结束标记在每一篇文章底部添加 -------------本文结束-------------文本 在 /themes/next/layout/_macro/ 下新建 passage-end-tag.swig,新增内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #555;font-size:14px;&quot;&gt;-------------本文结束-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 打开 \themes\next\layout\_macro\post.swig 搜索 END POST BODY,修改如下 123456789 &#123;#####################&#125; &#123;### END POST BODY ###&#125; &#123;#####################&#125; &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 最后在主题配置文件末尾添加 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 版权信息每篇文章底部的版权信息在 themes/next/layout/_macro/下添加 my-copyright.swig,新增内容 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在 themes/next/source/css/_common/components/post/新增样式文件my-post-copyright.styl, 添加内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改 themes/next/layout/_macro/post.swig 搜索 END POST BODY,如果有上一条的结束标记,就在结束标记内容后,添加,这里可以选择加在打赏之前还是之后 123456&lt;!--版权信息--&gt; &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; 修改 themes/next/source/css/_common/components/post/post.styl 在最后一行引入样式表 @import “my-post-copyright” 修改默认样式 hexo根目录/scaffolds/post.md 以及 hexo根目录/scaffolds/draft.md 在title,tag同级添加内容如下 1copyright: true 这样每一篇默认都会有版权信息 复制的时候带入版权信息待处理 分享功能使用addthis 注册完找到Profile Options -&gt; General -&gt; ID 然后 到Tools -&gt; Add New Tool, 创建一个inline类型的样式 最后到主题配置文件,修改add_this_id 1234# Share 分享#jiathis: true# Warning: JiaThis does not support https. 实际支持httpsadd_this_id: &#123;your AddThis ID&#125; 背景动画 修改主题配置文件 ,需要什么动画,设置为true即可 1234567891011# Canvas-nest 连接线canvas_nest: false# three_waves 波浪线three_waves: false# canvas_lines 三维canvas_lines: true # canvas_sphere 三维球canvas_sphere: false 其他功能实现小心心❤️实现点击出现小心心,但是有鼠标双击无法选择单词的问题 在/themes/next/source/js/src 新建love.js 将love.js的内容拷贝到love.js中 找到 \themes\next\layout\_layout.swig 在末尾添加 1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 代码高亮样式修改 主题配置文件 123456# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-theme# 代码样式,normal 就是白底黑字, night 就是黑底highlight_theme: normal 小型代码块颜色修改 \themes\next\source\css\_variables\base.styl 中 $code-background和$code-foreground的值 12345678// Code &amp; Code Blocks// --------------------------------------------------$code-font-family = $font-family-monospace$code-font-size = 13px$code-font-size = unit(hexo-config(&apos;font.codes.size&apos;), px) if hexo-config(&apos;font.codes.size&apos;) is a &apos;unit&apos;$code-border-radius = 3px$code-foreground = $black-light$code-background = $gainsboro 文章添加Github快捷Github有两种样式: 三角和条形 选择喜欢的样式复制到 themes/next/layout/_layout.swig的 &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面,并且修改href=&quot;&quot;为你自己的Github地址 调整 width和height 修改宽高 即可 文章加密在hexo根目录,输入 1$ npm install hexo-encrypt --save 配置 站点配置文件 ,末尾添加 123# 默认密码encrypt: password: 123456 修改 scaffolds/post.md 在--- 之间添加 12encrypt: falseenc_pwd: 123456 使用数学公式主要是一些数学公式方便引入 12345# MathJax Supportmathjax: enable: true per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 学习资料 https://mathjax-chinese-doc.readthedocs.io/en/latest/start.html 参考文档NexT 官方文档 图标库 Alvabill的简书 关于加密]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 简单美化]]></title>
    <url>%2F2018%2F09%2F12%2FHexo%20%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言前一篇中基本搭建好Hexo博客框架,也能访问,默认使用的主题是landscope ,主题可配置内容较少 加个看板娘可以首先看看效果图, 官方中文文档具体已经介绍了如何使用,懒得看文档的至少看下效果图 首先加载动画模块npm install --save hexo-helper-live2d 添加代码在站点的_config 最后一行加入代码,注意缩进,不能有空格 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true 最重要的一步! 安装模型npm install 模型的包名 以上的代码如果要正确运行,需要安装wanko模型 npm install live2d-widget-model-wanko 重新部署hexo g -d 更多的模型官方文档中有很多其他模型,可以对照模型自己看看 首页内容缩略显示首页的内容如果多几篇,会发现,首页内容好多,内容完全展示出来了 这里介绍markdown 的解决办法在在编写markdown时,在需要的地方加上 &lt;!-- more --&gt; 即可精确截断 后面切换nexT 主题,会用到自动截断 这篇文章就是主题可配置内容较少 文本内容之后截断,可以查看效果]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何优雅的创建Hexo]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%88%9B%E5%BB%BAHexo%2F</url>
    <content type="text"><![CDATA[什么是Hexo官方的解释是: Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 为什么使用Hexo先看效果: 我的博客 点击 人图标 学习 在搭建的过程中,能够明显感觉到Hexo组件化的架构,高度自由定制化的操作,可以在搭建的过程中学习 简单 对于程序员来说,复杂的问题简单化是一个基本技能,也是基本需求 多平台,准入低 可以自由的在Mac,Linux,Windows 搭建 托管平台可以选择github, Coding 等很多托管平台 Markdown 友好型 对于经常编写markdown的人来说,使用一个原生支持markdown的博客框架是一个很Cool的事. 准备工作 电脑一台 [必须] 注册一个代码托管平台(Github,Coding等) [必须] 最好拥有一个自己的域名 [可选] 环境搭建安装Git环境 Linux环境 Ubuntu, Debian $ sudo apt-get install git-core Fedora, Red Hat, CentOS $ sudo yum install git-core Mac环境 $ brew install git Windows(谨慎) 下载安装,官方 下载并安装,百度云收录 安装node环境mac已经安装好node环境 Linux 和 Windows 遵循以下2步: 第一步 $ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 或者 $ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 第二步 $ nvm install stable 如果失败,访问http://nodejs.org/下载安装 Tips: node一般使用RVM(Node Version Manager) 安装和升级 node的包管理使用的npm(node package Manager) 下载安装package的 安装Hexo博客框架$ npm install hexo-cli -g 框架安装成功! Hexo需要放到哪里?目录名称叫什么? mac为例,我需要放到文稿下,创建Hexo目录 $ cd ~/Documents/ &amp;&amp; hexo init Hexo &amp;&amp; cd Hexo 开始安装依赖 $ npm install 查看目录结构 12345678.├── _config.yml --&gt; 配置文件,整体配置├── package.json --&gt; 依赖├── scaffolds --&gt; 模板,默认3个,可以自己定义├── source --&gt; 所有的资源文件| ├── _drafts --&gt; 根据drafts创建的草稿文件| └── _posts --&gt; 根据post模板创建的文件└── themes --&gt; 主题,重点修改,内部每个主题的_config.yml是具体配置 Hexo 的 Hello World简单配置Hexo配置文件: _config.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: WilliamJi&apos;s Blog # 站点名称subtitle: Coder can change world! # 副标题,有些主题不展示...比如Nextdescription: One minute on the stage needs ten years practice off stage! #自我介绍keywords: 个人博客 iOS # 关键词author: William Ji # 作者email: jxjmdx2009@163.com #你的联系邮箱language: zh_CN # 语言,支持的语言到主题 themes/landscope/language下找timezone: Asia/Shanghai # 时区,可不填# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.com # 先不修改root: /permalink: :year/:month/:day/:title/ # 文章永久的链接格式,可添加.html结尾permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: # 跳过渲染的文件 - README.md - CNAME# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/# 时间格式化类型date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions 主题## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 模式人landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: 查看更多设置 查看效果$ hexo g &amp;&amp; hexo server -p 4000 tips: hexo g 是generate的意思,将.md文件根据配置文件生成预期的网页 hexo server 简写为hexo s也可以 -p 4000是指定端口,默认就是4000,可以直接 hexo s 注意命令行里面的提示语:Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 解释: 如果是远程服务器, localhost必须是具体的远程IP, 注意一定要使用ctrl+C 停止服务器,要不然端口4000就被占用! 解决端口占用的办法有3个: 重启终端 hexo server -p 换个端口 查看谁占用: lsof -i :4000 找到占用进程的PID填到后面的命令中 kill -9 PID 结束进程 可以不断修改配置_config.yml并且查看改动了启动服务器步骤: ctrl + c 关闭进程 hexo g &amp;&amp; hexo s tips : 关于命令A &amp;&amp; B意思是A成功的情况下执行B, A || B 是A失败的情况下执行B, A | B 是将A的输出当做B的输入,(A,B,C)是无论有没有切换上下文(目录),A,B,C都是在同一个上下文(目录)执行 Hexo 托管托管就是不仅仅在本地运行,上传到免费的托管平台,其他人也可以访问到 如果拥有远程服务器, hexo s 可以直接访问 ip:4000 访问 _config 部署介绍 Hexo 托管到Github大部分人的选择,代码是开源的 安装package$ npm install hexo-deployer-git --save 配置用户名和昵称将Github的用户名和昵称配上 $ git config --global user.name &quot;Your user.name&quot; $ git config --global user.email &quot;You user.email&quot; 配置SSH 秘钥在Hexo运行的环境上输入命令 user.email 输入Github的邮箱地址 ssh-keygen -t rsa -C user.email 保存的地址选择 /root/.ssh/id_rsa 然后回车 查看id_rsa.pub 的公钥信息 到Github公钥中 点击new ssh key 添加进去 创建托管仓库创建名称格式为(user.name).github.io的仓库,user.name 为Github的昵称 修改Hexo配置在 _config 中最后修改 1234deploy: type: git repo: git@github.com:(name)/(name).github.io.git #括号里面换成自己的用户名和仓库名,去掉括号 branch: master 部署生成文件并且部署: hexo g -d 然后访问 userName.github.io,比如我的 http://JXWilliamJi.github.io HTTPS到Github的Setting中 勾选 Enforce HTTPS 以后访问 https://JXWilliamJi.github.io 托管到Coding.netGithub免费账户不支持私有库,如果需要私有仓库必须付费,但是Coding.net免费用户支持私有库! 先去注册账号,https://coding.net/login 创建仓库,名称随意比如创建一个名称为william的项目 开启Pages服务找到代码-&gt;Pages 然后 点击 一键开启Pages 稍后看到如下信息 123访问地址Fastlane.coding.me/william部署时间2017-07-12 17:00:40部署版本b488bfa7b3 修改Hexo配置在 _config 中最后修改 1234deploy: type: git repo: git@git.coding.net:Fastlane/william.git branch: master 这里有个问题如果直接hexo g -d 看到的是没有样式的网页 一般的解决办法是推荐你买个域名,但是不用这么麻烦 在站点目录下 找到root,将域名后的文本添加上去 1234url: http://yoursite.comroot: /william # 修改这里permalink: :year/:month/:day/:title/permalink_defaults: 部署公钥在项目的设置里面找到 部署公钥 点击 新建部署公钥 将 id_rsa.pub 的公钥信息复制进去 重新部署hexo g -d https://Fastlane.coding.me/william 就能访问啦! 同时托管两个平台吃饱了撑的,但是可以做到 修改_config.xml 12url: http://yoursite.comroot: /william # 修改这里 12345678# 修改这个deploy:- type: git repo: git@github.com:(name)/(name).github.io.git #括号里面换成自己的用户名和仓库名,去掉括号 branch: master- type: git repo: git@github.com:(name)/(name).github.io.git #括号里面换成自己的用户名和仓库名,去掉括号 branch: master 或者换个语法 1234deploy: type: git repo: github: git@github.com:(name)/(name).github.io.git,master coding: git@github.com:(name)/(name).github.io.git,master 配置和单独配置相同 访问直接访问 (name).github.io/william 或者访问 Fastlane.coding.me/william 域名有了博客,最好买个域名,绑定域名更加高大上 Github:去自己的域名下添加解析记录类型为 CNAME 主机记录为 www/@ 线路选择默认，TTL 选择 600，记录值为 github 的仓库名 (name).github.io 主机记录可以选择www/@, www 访问的是https://www.domain.com @ 访问的是 https://domain.com 配置Hexocd hexo &amp;&amp; touch /source/CNAME 添加域名zhangsan.com 到 CNAME 中 重新部署 hexo g -d Coding.net方法和上面一样,选一个绑吧…没办法两个都绑 结语现在我们的博客可以使用了… 但是默认的主题不好看! 虽然能用,但是我们需要更加漂亮的外观和炫酷的视觉效果! 后面介绍如何优化以及使用主题 参考文档官方网站 https://hexo.io/zh-cn/ 部署Coding https://www.cnblogs.com/tengj/p/5352572.html]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
